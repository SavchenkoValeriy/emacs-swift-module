{"primaryContentSections":[{"kind":"content","content":[{"type":"heading","level":2,"text":"Environment Lifetime","anchor":"Environment-Lifetime"},{"inlineContent":[{"type":"text","text":"Environment lives as long as the function it was given to executes. This covers both module initialization and Lisp functions defined in Swift. Using environment outside of its lifetime will most likely crash Emacs. You can think of "},{"isActive":true,"identifier":"doc:\/\/EmacsSwiftModule\/documentation\/EmacsSwiftModule\/Environment","type":"reference"},{"text":" to be always an unowned reference.","type":"text"}],"type":"paragraph"},{"inlineContent":[{"type":"text","text":"This means that storing "},{"type":"reference","identifier":"doc:\/\/EmacsSwiftModule\/documentation\/EmacsSwiftModule\/Environment","isActive":true},{"text":" as part of some state, or capturing it in a closure that will be used afterwards is not going to work. The most typical problem looks somwehat like this:","type":"text"}],"type":"paragraph"},{"type":"codeListing","code":["try env.defun(\"test\") {","  \/\/ some code before","  try env.funcall(\"lisp-function\")","  \/\/ some code after","}"],"syntax":"swift"},{"inlineContent":[{"type":"text","text":"When the function does a lot of things, it’s hard to spot the fact that we are actually using the wrong environment. We captured the one from the outer scope, and using it here will cause Emacs to crash. Instead, we can explicitly ask for a new instance of "},{"identifier":"doc:\/\/EmacsSwiftModule\/documentation\/EmacsSwiftModule\/Environment","isActive":true,"type":"reference"},{"type":"text","text":" in every Swift-defined Lisp function."}],"type":"paragraph"},{"type":"codeListing","syntax":"swift","code":["try env.defun(\"test\") {","  (env: Environment) in","  \/\/ some code before","  try env.funcall(\"lisp-function\")","  \/\/ some code after","}"]},{"inlineContent":[{"text":"This code doesn’t change the number of required arguments to call ","type":"text"},{"code":"test","type":"codeVoice"},{"type":"text","text":", Emacs already passes a new environment with every function invocation. This way we just ask "},{"identifier":"doc:\/\/EmacsSwiftModule\/documentation\/EmacsSwiftModule\/Environment","type":"reference","isActive":true},{"type":"text","text":" to pass it to us on call."}],"type":"paragraph"},{"type":"paragraph","inlineContent":[{"text":"This lifetime restriction ensures one of the core principles of Emacs dynamic modules ","type":"text"},{"inlineContent":[{"type":"text","text":"“Emacs calls into then module’s code when it wants to, not the other way around”"}],"type":"strong"},{"type":"text","text":". Using "},{"identifier":"doc:\/\/EmacsSwiftModule\/documentation\/EmacsSwiftModule\/Environment","type":"reference","isActive":true},{"type":"text","text":" outside of its lifetime means calling into Emacs asynchronously when Emacs does not expect it to happen. That will violate its concurrency model."}]},{"inlineContent":[{"type":"text","text":"In order to ensure this requirement, "},{"identifier":"doc:\/\/EmacsSwiftModule\/documentation\/EmacsSwiftModule\/Environment","isActive":true,"type":"reference"},{"type":"text","text":" has additional checks in place to spot lifetime violations and throw "},{"type":"reference","identifier":"doc:\/\/EmacsSwiftModule\/documentation\/EmacsSwiftModule\/EmacsError\/lifetimeViolation","isActive":true},{"text":" exception when it does. This way the very first snippet from this section won’t actually crash Emacs, but simply signal an error when calling the ","type":"text"},{"type":"codeVoice","code":"test"},{"type":"text","text":" function."}],"type":"paragraph"},{"anchor":"EmacsValue-Lifetime","level":2,"text":"EmacsValue Lifetime","type":"heading"},{"type":"paragraph","inlineContent":[{"text":"Similarly to ","type":"text"},{"isActive":true,"type":"reference","identifier":"doc:\/\/EmacsSwiftModule\/documentation\/EmacsSwiftModule\/Environment"},{"text":", opaque ","type":"text"},{"type":"reference","identifier":"doc:\/\/EmacsSwiftModule\/documentation\/EmacsSwiftModule\/EmacsValue","isActive":true},{"type":"text","text":" also has a limited lifetime. It is not enforced as strictly, and can produce even more confusion."}]},{"type":"paragraph","inlineContent":[{"text":"Essentially every ","type":"text"},{"isActive":true,"identifier":"doc:\/\/EmacsSwiftModule\/documentation\/EmacsSwiftModule\/EmacsValue","type":"reference"},{"type":"text","text":" is bound to the "},{"type":"reference","identifier":"doc:\/\/EmacsSwiftModule\/documentation\/EmacsSwiftModule\/Environment","isActive":true},{"type":"text","text":" instance that produced it. This means that "},{"identifier":"doc:\/\/EmacsSwiftModule\/documentation\/EmacsSwiftModule\/EmacsValue","type":"reference","isActive":true},{"type":"text","text":" has "},{"type":"emphasis","inlineContent":[{"type":"text","text":"the same lifetime"}]},{"type":"text","text":" as its "},{"type":"reference","identifier":"doc:\/\/EmacsSwiftModule\/documentation\/EmacsSwiftModule\/Environment","isActive":true},{"text":". In the most probable scenario, you produce a value and use it with the same environment. Nothing to worry about in this case!","type":"text"}]},{"syntax":"swift","code":["let value = try env.funcall(\"foo\")","try env.funcall(\"bar\", with: value)"],"type":"codeListing"},{"type":"paragraph","inlineContent":[{"text":"The problem comes when you want to keep certain value and share it between two environments.","type":"text"}]},{"code":["var stash: EmacsValue = env.Nil","try env.defun(\"stash-arg\") {","  (arg: EmacsValue) in stash = arg","}","try env.defun(\"get-stash\") {","  stash","}"],"type":"codeListing","syntax":"swift"},{"type":"paragraph","inlineContent":[{"text":"It should not work because of the lifetimes violation, but in most cases it does. On my machine, this code works as the user expected it to work. However, if we modify it a little bit, we can receive some very confusing results.","type":"text"}]},{"code":["var stash = [EmacsValue]()","try env.defun(\"stash-arg\") {","  (arg: EmacsValue) in stash.append(arg)","}","try env.defun(\"get-stash\") {","  stash","}"],"syntax":"swift","type":"codeListing"},{"inlineContent":[{"type":"text","text":"Looks very much the same, we keep all the arguments instead of the last one. So, what would be the problem?"}],"type":"paragraph"},{"type":"codeListing","syntax":"emacs-lisp","code":["(stash-arg 1)","(stash-arg 2)","(stash-arg 3)","(get-stash) ;; => [3 3 3]"]},{"inlineContent":[{"type":"text","text":"It returns a vector of "},{"type":"codeVoice","code":"3"},{"type":"text","text":"s! The size is right, the last value is right, but the whole vector shares the same value. It is especially strange after the previous example. The reason is the lifetime of "},{"type":"codeVoice","code":"arg"},{"type":"text","text":", in this situation it is not enforced. However, Emacs reuses the same memory to store a new argument value every time. It is just an implementation detail of Emacs that we discovered accidentally. We should "},{"type":"emphasis","inlineContent":[{"text":"never","type":"text"}]},{"type":"text","text":" rely on such undocumented features. They can change from one release to another, and behave differently on different platforms."}],"type":"paragraph"},{"type":"paragraph","inlineContent":[{"type":"text","text":"Instead, we should use "},{"isActive":true,"type":"reference","identifier":"doc:\/\/EmacsSwiftModule\/documentation\/EmacsSwiftModule\/PersistentEmacsValue"},{"type":"text","text":"."}]},{"type":"codeListing","syntax":"swift","code":["var stash = [EmacsValue]()","try env.defun(\"stash-arg\") {","  (arg: PersistentEmacsValue) in stash.append(arg)","}","try env.defun(\"get-stash\") {","  stash","}"]},{"type":"paragraph","inlineContent":[{"text":"This fixes it! We just changed parameter type of our function and that’s enough! This way we tell ","type":"text"},{"type":"codeVoice","code":"EmacsSwiftModule"},{"type":"text","text":" that actually the Swift side should take care of this value’s lifetime. "},{"identifier":"doc:\/\/EmacsSwiftModule\/documentation\/EmacsSwiftModule\/PersistentEmacsValue","isActive":true,"type":"reference"},{"text":" effectively marries Swift’s ARC and Emacs’ garbage collection, so we can share values across environments.","type":"text"}]},{"type":"paragraph","inlineContent":[{"type":"reference","identifier":"doc:\/\/EmacsSwiftModule\/documentation\/EmacsSwiftModule\/PersistentEmacsValue","isActive":true},{"text":" also works with ","type":"text"},{"type":"codeVoice","code":"funcall"},{"text":" and ","type":"text"},{"type":"codeVoice","code":"apply"},{"type":"text","text":" result type inference, so you can write:"}]},{"code":["let x: PersistentEmacsValue = try env.funcall(\"foo\")","let y = try env.funcall(\"bar\") as PersistentEmacsValue"],"type":"codeListing","syntax":"swift"},{"inlineContent":[{"type":"text","text":"If you already have "},{"isActive":true,"type":"reference","identifier":"doc:\/\/EmacsSwiftModule\/documentation\/EmacsSwiftModule\/EmacsValue"},{"type":"text","text":", you can turn it into "},{"type":"reference","identifier":"doc:\/\/EmacsSwiftModule\/documentation\/EmacsSwiftModule\/PersistentEmacsValue","isActive":true},{"text":" by calling ","type":"text"},{"identifier":"doc:\/\/EmacsSwiftModule\/documentation\/EmacsSwiftModule\/Environment\/preserve(_:)","type":"reference","isActive":true},{"text":".","type":"text"}],"type":"paragraph"},{"type":"codeListing","syntax":"swift","code":["let lambda = try env.preserve(env.defun {","  \/\/ do some cool stuff","})"]},{"inlineContent":[{"type":"text","text":"After preservation, "},{"type":"codeVoice","code":"lambda"},{"type":"text","text":" can be safely used from different functions."}],"type":"paragraph"},{"type":"aside","style":"note","name":"Info","content":[{"inlineContent":[{"type":"text","text":""},{"type":"reference","isActive":true,"identifier":"doc:\/\/EmacsSwiftModule\/documentation\/EmacsSwiftModule\/Environment"},{"text":" also provides ","type":"text"},{"isActive":true,"type":"reference","identifier":"doc:\/\/EmacsSwiftModule\/documentation\/EmacsSwiftModule\/Environment\/retain(_:)"},{"type":"text","text":" and "},{"isActive":true,"type":"reference","identifier":"doc:\/\/EmacsSwiftModule\/documentation\/EmacsSwiftModule\/Environment\/release(_:)"},{"type":"text","text":" low-level APIs for manual reference-counting. But "},{"isActive":true,"identifier":"doc:\/\/EmacsSwiftModule\/documentation\/EmacsSwiftModule\/PersistentEmacsValue","type":"reference"},{"text":" and ","type":"text"},{"type":"reference","identifier":"doc:\/\/EmacsSwiftModule\/documentation\/EmacsSwiftModule\/Environment\/preserve(_:)","isActive":true},{"text":" should be preferred to avoid mistakes.","type":"text"}],"type":"paragraph"}]},{"type":"heading","text":"Concurrency","level":2,"anchor":"Concurrency"},{"type":"paragraph","inlineContent":[{"type":"text","text":"As it was mentioned earlier, "},{"identifier":"doc:\/\/EmacsSwiftModule\/documentation\/EmacsSwiftModule\/Environment","type":"reference","isActive":true},{"type":"text","text":" lifetime restriction comes from the desire to keep Emacs own concurrency model intact. This also includes another rule for using "},{"identifier":"doc:\/\/EmacsSwiftModule\/documentation\/EmacsSwiftModule\/Environment","type":"reference","isActive":true},{"type":"text","text":" - it should be used on the same thread it was created on. It is important to keep it mind, even considering that using "},{"isActive":true,"identifier":"doc:\/\/EmacsSwiftModule\/documentation\/EmacsSwiftModule\/Environment","type":"reference"},{"text":" asynchronously will most likely violate its lifetime. To learn how to mix asynchronous code with Emacs interactions, please refer to ","type":"text"},{"type":"reference","identifier":"doc:\/\/EmacsSwiftModule\/documentation\/EmacsSwiftModule\/AsyncCallbacks","isActive":true},{"text":".","type":"text"}]},{"type":"paragraph","inlineContent":[{"text":"Similarly to lifetime violations, ","type":"text"},{"isActive":true,"identifier":"doc:\/\/EmacsSwiftModule\/documentation\/EmacsSwiftModule\/Environment","type":"reference"},{"text":" validates that its user follows Emacs concurrency model and throws ","type":"text"},{"identifier":"doc:\/\/EmacsSwiftModule\/documentation\/EmacsSwiftModule\/EmacsError\/threadModelViolation","type":"reference","isActive":true},{"type":"text","text":" when "},{"isActive":true,"type":"reference","identifier":"doc:\/\/EmacsSwiftModule\/documentation\/EmacsSwiftModule\/Environment"},{"text":" is attempted to be used on the other thread.","type":"text"}]}]}],"sections":[],"metadata":{"modules":[{"name":"EmacsSwiftModule"}],"roleHeading":"Article","title":"Lifetimes","role":"article"},"identifier":{"interfaceLanguage":"swift","url":"doc:\/\/EmacsSwiftModule\/documentation\/EmacsSwiftModule\/Lifetimes"},"schemaVersion":{"patch":0,"major":0,"minor":3},"variants":[{"traits":[{"interfaceLanguage":"swift"}],"paths":["\/documentation\/emacsswiftmodule\/lifetimes"]}],"seeAlsoSections":[{"title":"Advanced","identifiers":["doc:\/\/EmacsSwiftModule\/documentation\/EmacsSwiftModule\/AsyncCallbacks"],"generated":true}],"kind":"article","abstract":[{"type":"text","text":"Emacs internals lifetimes."}],"hierarchy":{"paths":[["doc:\/\/EmacsSwiftModule\/documentation\/EmacsSwiftModule"],["doc:\/\/EmacsSwiftModule\/documentation\/EmacsSwiftModule","doc:\/\/EmacsSwiftModule\/documentation\/EmacsSwiftModule\/Environment"]]},"references":{"doc://EmacsSwiftModule/documentation/EmacsSwiftModule":{"role":"collection","abstract":[{"type":"text","text":"A Swift library to write Emacs plugins in Swift!"}],"title":"EmacsSwiftModule","url":"\/documentation\/emacsswiftmodule","identifier":"doc:\/\/EmacsSwiftModule\/documentation\/EmacsSwiftModule","kind":"symbol","type":"topic"},"doc://EmacsSwiftModule/documentation/EmacsSwiftModule/Environment/release(_:)":{"type":"topic","kind":"symbol","url":"\/documentation\/emacsswiftmodule\/environment\/release(_:)","title":"release(_:)","fragments":[{"text":"func","kind":"keyword"},{"text":" ","kind":"text"},{"text":"release","kind":"identifier"},{"text":"(","kind":"text"},{"text":"EmacsValue","preciseIdentifier":"s:16EmacsSwiftModule0A5ValueC","kind":"typeIdentifier"},{"text":") ","kind":"text"},{"text":"throws","kind":"keyword"}],"role":"symbol","abstract":[{"type":"text","text":"Release the given value."}],"identifier":"doc:\/\/EmacsSwiftModule\/documentation\/EmacsSwiftModule\/Environment\/release(_:)"},"doc://EmacsSwiftModule/documentation/EmacsSwiftModule/PersistentEmacsValue":{"role":"symbol","type":"topic","kind":"symbol","title":"PersistentEmacsValue","url":"\/documentation\/emacsswiftmodule\/persistentemacsvalue","fragments":[{"kind":"keyword","text":"class"},{"kind":"text","text":" "},{"text":"PersistentEmacsValue","kind":"identifier"}],"abstract":[{"text":"An Emacs value that can be safely copied and stored.","type":"text"}],"identifier":"doc:\/\/EmacsSwiftModule\/documentation\/EmacsSwiftModule\/PersistentEmacsValue","navigatorTitle":[{"kind":"identifier","text":"PersistentEmacsValue"}]},"doc://EmacsSwiftModule/documentation/EmacsSwiftModule/Environment/retain(_:)":{"type":"topic","kind":"symbol","url":"\/documentation\/emacsswiftmodule\/environment\/retain(_:)","title":"retain(_:)","fragments":[{"text":"func","kind":"keyword"},{"text":" ","kind":"text"},{"text":"retain","kind":"identifier"},{"text":"(","kind":"text"},{"preciseIdentifier":"s:16EmacsSwiftModule0A5ValueC","text":"EmacsValue","kind":"typeIdentifier"},{"text":") ","kind":"text"},{"text":"throws","kind":"keyword"},{"kind":"text","text":" -> "},{"text":"EmacsValue","kind":"typeIdentifier","preciseIdentifier":"s:16EmacsSwiftModule0A5ValueC"}],"role":"symbol","abstract":[{"type":"text","text":"Retain the given value."}],"identifier":"doc:\/\/EmacsSwiftModule\/documentation\/EmacsSwiftModule\/Environment\/retain(_:)"},"doc://EmacsSwiftModule/documentation/EmacsSwiftModule/EmacsError/lifetimeViolation":{"identifier":"doc:\/\/EmacsSwiftModule\/documentation\/EmacsSwiftModule\/EmacsError\/lifetimeViolation","abstract":[{"type":"text","text":"Using "},{"type":"reference","identifier":"doc:\/\/EmacsSwiftModule\/documentation\/EmacsSwiftModule\/Environment","isActive":true},{"text":" outside of its scope.","type":"text"}],"type":"topic","title":"EmacsError.lifetimeViolation","url":"\/documentation\/emacsswiftmodule\/emacserror\/lifetimeviolation","kind":"symbol","role":"symbol","fragments":[{"text":"case","kind":"keyword"},{"kind":"text","text":" "},{"kind":"identifier","text":"lifetimeViolation"}]},"doc://EmacsSwiftModule/documentation/EmacsSwiftModule/EmacsValue":{"role":"symbol","type":"topic","title":"EmacsValue","kind":"symbol","url":"\/documentation\/emacsswiftmodule\/emacsvalue","fragments":[{"kind":"keyword","text":"class"},{"text":" ","kind":"text"},{"kind":"identifier","text":"EmacsValue"}],"abstract":[{"type":"text","text":"An opaque Emacs value representing something from the Emacs Lisp world."}],"identifier":"doc:\/\/EmacsSwiftModule\/documentation\/EmacsSwiftModule\/EmacsValue","navigatorTitle":[{"kind":"identifier","text":"EmacsValue"}]},"doc://EmacsSwiftModule/documentation/EmacsSwiftModule/AsyncCallbacks":{"role":"article","type":"topic","title":"Asynchronous Callbacks","kind":"article","url":"\/documentation\/emacsswiftmodule\/asynccallbacks","abstract":[{"text":"Calling Lisp functions without an active Environment.","type":"text"}],"identifier":"doc:\/\/EmacsSwiftModule\/documentation\/EmacsSwiftModule\/AsyncCallbacks"},"doc://EmacsSwiftModule/documentation/EmacsSwiftModule/Environment/preserve(_:)":{"type":"topic","kind":"symbol","url":"\/documentation\/emacsswiftmodule\/environment\/preserve(_:)","title":"preserve(_:)","fragments":[{"text":"func","kind":"keyword"},{"kind":"text","text":" "},{"text":"preserve","kind":"identifier"},{"text":"(","kind":"text"},{"preciseIdentifier":"s:16EmacsSwiftModule0A5ValueC","text":"EmacsValue","kind":"typeIdentifier"},{"text":") ","kind":"text"},{"text":"throws","kind":"keyword"},{"text":" -> ","kind":"text"},{"text":"PersistentEmacsValue","preciseIdentifier":"s:16EmacsSwiftModule010PersistentA5ValueC","kind":"typeIdentifier"}],"role":"symbol","abstract":[{"type":"text","text":"Return a persistent version of the given value."}],"identifier":"doc:\/\/EmacsSwiftModule\/documentation\/EmacsSwiftModule\/Environment\/preserve(_:)"},"doc://EmacsSwiftModule/documentation/EmacsSwiftModule/EmacsError/threadModelViolation":{"identifier":"doc:\/\/EmacsSwiftModule\/documentation\/EmacsSwiftModule\/EmacsError\/threadModelViolation","abstract":[{"type":"text","text":"Using "},{"isActive":true,"type":"reference","identifier":"doc:\/\/EmacsSwiftModule\/documentation\/EmacsSwiftModule\/Environment"},{"type":"text","text":" in a different thread than issued it."}],"type":"topic","title":"EmacsError.threadModelViolation","kind":"symbol","url":"\/documentation\/emacsswiftmodule\/emacserror\/threadmodelviolation","role":"symbol","fragments":[{"text":"case","kind":"keyword"},{"kind":"text","text":" "},{"kind":"identifier","text":"threadModelViolation"}]},"doc://EmacsSwiftModule/documentation/EmacsSwiftModule/Environment":{"role":"symbol","type":"topic","title":"Environment","kind":"symbol","url":"\/documentation\/emacsswiftmodule\/environment","fragments":[{"kind":"keyword","text":"class"},{"text":" ","kind":"text"},{"kind":"identifier","text":"Environment"}],"abstract":[{"type":"text","text":"Environment is the interaction point with Emacs. If you want to do anything on the Emacs side, you need to have an Environment."}],"identifier":"doc:\/\/EmacsSwiftModule\/documentation\/EmacsSwiftModule\/Environment","navigatorTitle":[{"kind":"identifier","text":"Environment"}]}}}