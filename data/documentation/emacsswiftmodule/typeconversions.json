{"variants":[{"traits":[{"interfaceLanguage":"swift"}],"paths":["\/documentation\/emacsswiftmodule\/typeconversions"]}],"primaryContentSections":[{"kind":"content","content":[{"text":"Static vs Dynamic Types","level":2,"anchor":"Static-vs-Dynamic-Types","type":"heading"},{"inlineContent":[{"type":"text","text":"Emacs Lisp is a dynamically typed language meaning that every Lisp variable or symbol can potentially carry a value of any type. Passing a value of a some type into a function that doesn’t expect that type causes a runtime error. Swift, on the other hand is statically typed. The power of statically-typed languages comes from harder guarantees that the compiler enforces onto the language users."}],"type":"paragraph"},{"inlineContent":[{"text":"When we define a Lisp function in Swift using Swift types, we actually express runtime expectations that we have about the calls to this new function. The users are still able to write this code with incorrect arguments and they will know that they actually make a mistake only when they execute their code. At the same time, ","type":"text"},{"code":"EmacsSwiftModule","type":"codeVoice"},{"text":" guarantees that when you specify a Swift type for either a parameter or a call result, you’ll get a valid object of that type or an exception will be thrown.","type":"text"}],"type":"paragraph"},{"level":2,"text":"Opaque Dynamic Values","type":"heading","anchor":"Opaque-Dynamic-Values"},{"type":"paragraph","inlineContent":[{"text":"Underneath, at Emacs level, all values are typed as ","type":"text"},{"type":"reference","isActive":true,"identifier":"doc:\/\/EmacsSwiftModule\/documentation\/EmacsSwiftModule\/EmacsValue"},{"type":"text","text":". And as it was mentioned in "},{"identifier":"doc:\/\/EmacsSwiftModule\/documentation\/EmacsSwiftModule\/DefiningLispFunctions","type":"reference","isActive":true},{"text":", the module developer can request to process value of that type instead of specifying any of the Swift types. Actually, the developer can even use a mixture of static and dynamic types in their code by using types like ","type":"text"},{"code":"[EmacsValue]","type":"codeVoice"},{"type":"text","text":" that will represent a Swift array of opaque Lisp values."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Each "},{"identifier":"doc:\/\/EmacsSwiftModule\/documentation\/EmacsSwiftModule\/EmacsValue","type":"reference","isActive":true},{"type":"text","text":" is tied to the "},{"type":"reference","identifier":"doc:\/\/EmacsSwiftModule\/documentation\/EmacsSwiftModule\/Environment","isActive":true},{"type":"text","text":" it comes from. This fact might cause some surprising effects if the value outlives its environment. See "},{"isActive":true,"identifier":"doc:\/\/EmacsSwiftModule\/documentation\/EmacsSwiftModule\/Lifetimes","type":"reference"},{"type":"text","text":" to understand it in full, and learn about "},{"type":"codeVoice","code":"EmacsSwiftModule"},{"type":"text","text":" mechanisms to make it easier for you."}]},{"anchor":"EmacsConvertible-Protocol","type":"heading","text":"EmacsConvertible Protocol","level":2},{"inlineContent":[{"code":"EmacsSwiftModule","type":"codeVoice"},{"text":" defines ","type":"text"},{"identifier":"doc:\/\/EmacsSwiftModule\/documentation\/EmacsSwiftModule\/EmacsConvertible","isActive":true,"type":"reference"},{"type":"text","text":" protocol that describes how each of the conforming types converts into "},{"isActive":true,"identifier":"doc:\/\/EmacsSwiftModule\/documentation\/EmacsSwiftModule\/EmacsValue","type":"reference"},{"type":"text","text":" and from it. It is important to understand that each conversion should always involve a valid "},{"type":"reference","identifier":"doc:\/\/EmacsSwiftModule\/documentation\/EmacsSwiftModule\/Environment","isActive":true},{"type":"text","text":" object."}],"type":"paragraph"},{"inlineContent":[{"type":"text","text":"You can manually do conversions with all of the conforming types as in the following example"}],"type":"paragraph"},{"type":"codeListing","syntax":"swift","code":["let value = try \"Hello Lisp\".convert(within: env)","let string = try String.convert(from: value, within: env)","assert(string == \"Hello Lisp\")"]},{"inlineContent":[{"type":"text","text":"As seen in this example, conversion functions "},{"isActive":true,"type":"reference","identifier":"doc:\/\/EmacsSwiftModule\/documentation\/EmacsSwiftModule\/EmacsConvertible\/convert(within:)-dic5"},{"text":" and ","type":"text"},{"identifier":"doc:\/\/EmacsSwiftModule\/documentation\/EmacsSwiftModule\/EmacsConvertible\/convert(from:within:)-2h782","type":"reference","isActive":true},{"type":"text","text":", and they are all you need to turn your type into "},{"type":"reference","identifier":"doc:\/\/EmacsSwiftModule\/documentation\/EmacsSwiftModule\/EmacsConvertible","isActive":true},{"text":".","type":"text"}],"type":"paragraph"},{"text":"Opaque Conversion","type":"heading","level":2,"anchor":"Opaque-Conversion"},{"type":"paragraph","inlineContent":[{"type":"text","text":"In many cases, you might want to share one of your reference type objects with the Lisp side, but as identity, not as a source of data. Let’s look at a simple example, I want my Swift API to allow Lisp users to create and delete buttons. And let’s say that underneath we want to use some "},{"type":"codeVoice","code":"FancyUI.Button"},{"type":"text","text":" class. We came up with a code like this, which seems very reasonable."}]},{"code":["try env.defun(\"button-create\") {","  (text: String) in FancyUI.Button(text)","}","try env.defun(\"button-delete\") {","  (button: FancyUI.Button) in button.delete()","}"],"type":"codeListing","syntax":"swift"},{"type":"paragraph","inlineContent":[{"type":"text","text":"But "},{"code":"FancyUI.Button","type":"codeVoice"},{"type":"text","text":" doesn’t conform to "},{"type":"reference","identifier":"doc:\/\/EmacsSwiftModule\/documentation\/EmacsSwiftModule\/EmacsConvertible","isActive":true},{"text":", and it’s hard to think of some good encoding to make it work. Swift has its own memory management, we don’t want to screw it up. Plus ","type":"text"},{"type":"codeVoice","code":"FancyUI.Button"},{"text":" is not our class to begin with, it’s pretty hard to find things that uniquely identify it. What is left is low-level APIs, but don’t we want to avoid it by using Swift in the first place!?","type":"text"}]},{"type":"paragraph","inlineContent":[{"text":"That’s absolutely right, and that’s why ","type":"text"},{"code":"EmacsSwiftModule","type":"codeVoice"},{"type":"text","text":" defines "},{"isActive":true,"type":"reference","identifier":"doc:\/\/EmacsSwiftModule\/documentation\/EmacsSwiftModule\/OpaquelyEmacsConvertible"},{"type":"text","text":". The protocol that comes with the default implementation. It converts any given class into an opaque Lisp object. Similarly to how "},{"type":"reference","identifier":"doc:\/\/EmacsSwiftModule\/documentation\/EmacsSwiftModule\/EmacsValue","isActive":true},{"type":"text","text":" is a black box in Swift, and how we can communicate with it only through "},{"identifier":"doc:\/\/EmacsSwiftModule\/documentation\/EmacsSwiftModule\/Environment","isActive":true,"type":"reference"},{"type":"text","text":", such opaque objects are black boxes in Lisp and make sense only together with your APIs. "},{"type":"reference","identifier":"doc:\/\/EmacsSwiftModule\/documentation\/EmacsSwiftModule\/OpaquelyEmacsConvertible","isActive":true},{"type":"text","text":" makes sure to marry Swift’s reference counters and Emacs’ garbage collection to avoid any surprises."}]},{"inlineContent":[{"text":"This being said, you can add the following piece to your code:","type":"text"}],"type":"paragraph"},{"syntax":"swift","type":"codeListing","code":["extension FancyUI.Button: OpaquelyEmacsConvertible {}"]},{"inlineContent":[{"type":"text","text":"and the code above will work as expected."}],"type":"paragraph"},{"type":"heading","level":2,"anchor":"Currently-supported-Type-Conversions","text":"Currently-supported Type Conversions"},{"items":[{"content":[{"inlineContent":[{"text":"Swift ","type":"text"},{"type":"codeVoice","code":"Int"},{"text":" into\/from Lisp ","type":"text"},{"type":"codeVoice","code":"integer"}],"type":"paragraph"}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Swift "},{"code":"Double","type":"codeVoice"},{"text":" into\/from Lisp ","type":"text"},{"type":"codeVoice","code":"float"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"text":"Swift ","type":"text"},{"code":"Bool","type":"codeVoice"},{"text":" into Lisp as ","type":"text"},{"code":"t\/nil","type":"codeVoice"},{"type":"text","text":". When converting from Lisp, any value but "},{"code":"nil","type":"codeVoice"},{"text":" is considered to be ","type":"text"},{"code":"true","type":"codeVoice"},{"type":"text","text":". "},{"code":"Bool","type":"codeVoice"},{"text":" is the only native type that doesn’t throw during conversion.","type":"text"}]}]},{"content":[{"inlineContent":[{"text":"Swift ","type":"text"},{"type":"codeVoice","code":"Optional"},{"type":"text","text":" if the underlying type is "},{"identifier":"doc:\/\/EmacsSwiftModule\/documentation\/EmacsSwiftModule\/EmacsConvertible","isActive":true,"type":"reference"},{"text":". Swift ","type":"text"},{"code":"nil","type":"codeVoice"},{"type":"text","text":" into\/from Lisp "},{"type":"codeVoice","code":"nil"},{"type":"text","text":", and other cases match the underlying type conversion."}],"type":"paragraph"}]},{"content":[{"inlineContent":[{"text":"Swift ","type":"text"},{"type":"codeVoice","code":"Array"},{"text":" if the element type is ","type":"text"},{"isActive":true,"type":"reference","identifier":"doc:\/\/EmacsSwiftModule\/documentation\/EmacsSwiftModule\/EmacsConvertible"},{"type":"text","text":", into\/from Lisp "},{"code":"vector","type":"codeVoice"},{"type":"text","text":" (not "},{"type":"codeVoice","code":"list"},{"type":"text","text":"). Maybe one day, we’ll decide to support "},{"type":"codeVoice","code":"list"},{"type":"text","text":" conversions as well, but one-to-many conversion can get pretty tricky and "},{"code":"vector","type":"codeVoice"},{"type":"text","text":" seems like a better match."}],"type":"paragraph"}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Swift "},{"type":"codeVoice","code":"Dictionary"},{"type":"text","text":" if the key and value types are both "},{"identifier":"doc:\/\/EmacsSwiftModule\/documentation\/EmacsSwiftModule\/EmacsConvertible","isActive":true,"type":"reference"},{"type":"text","text":", into\/from Lisp "},{"code":"alist","type":"codeVoice"},{"text":".","type":"text"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"identifier":"doc:\/\/EmacsSwiftModule\/documentation\/EmacsSwiftModule\/Symbol","isActive":true,"type":"reference"},{"text":" into\/from Lisp ","type":"text"},{"type":"codeVoice","code":"symbol"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"identifier":"doc:\/\/EmacsSwiftModule\/documentation\/EmacsSwiftModule\/ConsCell","isActive":true,"type":"reference"},{"type":"text","text":" into\/from Lisp "},{"type":"codeVoice","code":"cons"}]}]},{"content":[{"inlineContent":[{"isActive":true,"identifier":"doc:\/\/EmacsSwiftModule\/documentation\/EmacsSwiftModule\/List","type":"reference"},{"type":"text","text":" into\/from Lisp "},{"code":"list","type":"codeVoice"}],"type":"paragraph"}]}],"type":"unorderedList"}]}],"kind":"article","sections":[],"schemaVersion":{"patch":0,"minor":3,"major":0},"hierarchy":{"paths":[["doc:\/\/EmacsSwiftModule\/documentation\/EmacsSwiftModule"]]},"abstract":[{"text":"Converting Swift values into Lisp values and vice versa.","type":"text"}],"metadata":{"modules":[{"name":"EmacsSwiftModule"}],"title":"Type conversions","roleHeading":"Article","role":"article"},"seeAlsoSections":[{"identifiers":["doc:\/\/EmacsSwiftModule\/documentation\/EmacsSwiftModule\/DefiningAModule","doc:\/\/EmacsSwiftModule\/documentation\/EmacsSwiftModule\/CallingLispFunctions","doc:\/\/EmacsSwiftModule\/documentation\/EmacsSwiftModule\/DefiningLispFunctions","doc:\/\/EmacsSwiftModule\/documentation\/EmacsSwiftModule\/ErrorHandling"],"generated":true,"title":"Getting started"}],"identifier":{"url":"doc:\/\/EmacsSwiftModule\/documentation\/EmacsSwiftModule\/TypeConversions","interfaceLanguage":"swift"},"references":{"doc://EmacsSwiftModule/documentation/EmacsSwiftModule/List":{"role":"symbol","type":"topic","title":"List","kind":"symbol","url":"\/documentation\/emacsswiftmodule\/list","fragments":[{"kind":"keyword","text":"enum"},{"text":" ","kind":"text"},{"kind":"identifier","text":"List"}],"abstract":[{"type":"text","text":"A simple list implementation that allows the most transparent conversion between two worlds."}],"identifier":"doc:\/\/EmacsSwiftModule\/documentation\/EmacsSwiftModule\/List","navigatorTitle":[{"kind":"identifier","text":"List"}]},"doc://EmacsSwiftModule/documentation/EmacsSwiftModule":{"role":"collection","abstract":[{"type":"text","text":"A Swift library to write Emacs plugins in Swift!"}],"title":"EmacsSwiftModule","url":"\/documentation\/emacsswiftmodule","identifier":"doc:\/\/EmacsSwiftModule\/documentation\/EmacsSwiftModule","kind":"symbol","type":"topic"},"doc://EmacsSwiftModule/documentation/EmacsSwiftModule/Symbol":{"role":"symbol","type":"topic","kind":"symbol","title":"Symbol","url":"\/documentation\/emacsswiftmodule\/symbol","fragments":[{"kind":"keyword","text":"struct"},{"kind":"text","text":" "},{"text":"Symbol","kind":"identifier"}],"abstract":[{"type":"text","text":"Emacs named symbol"}],"identifier":"doc:\/\/EmacsSwiftModule\/documentation\/EmacsSwiftModule\/Symbol","navigatorTitle":[{"kind":"identifier","text":"Symbol"}]},"doc://EmacsSwiftModule/documentation/EmacsSwiftModule/Environment":{"role":"symbol","type":"topic","title":"Environment","kind":"symbol","url":"\/documentation\/emacsswiftmodule\/environment","fragments":[{"kind":"keyword","text":"class"},{"text":" ","kind":"text"},{"kind":"identifier","text":"Environment"}],"abstract":[{"type":"text","text":"Environment is the interaction point with Emacs. If you want to do anything on the Emacs side, you need to have an Environment."}],"identifier":"doc:\/\/EmacsSwiftModule\/documentation\/EmacsSwiftModule\/Environment","navigatorTitle":[{"kind":"identifier","text":"Environment"}]},"doc://EmacsSwiftModule/documentation/EmacsSwiftModule/Lifetimes":{"role":"article","type":"topic","kind":"article","title":"Lifetimes","url":"\/documentation\/emacsswiftmodule\/lifetimes","abstract":[{"type":"text","text":"Emacs internals lifetimes."}],"identifier":"doc:\/\/EmacsSwiftModule\/documentation\/EmacsSwiftModule\/Lifetimes"},"doc://EmacsSwiftModule/documentation/EmacsSwiftModule/EmacsConvertible/convert(within:)-dic5":{"role":"symbol","kind":"symbol","title":"convert(within:)","defaultImplementations":1,"type":"topic","required":true,"identifier":"doc:\/\/EmacsSwiftModule\/documentation\/EmacsSwiftModule\/EmacsConvertible\/convert(within:)-dic5","url":"\/documentation\/emacsswiftmodule\/emacsconvertible\/convert(within:)-dic5","abstract":[{"type":"text","text":"Convert current Swift value into "},{"code":"EmacsValue","type":"codeVoice"},{"type":"text","text":" within the given environment."}],"fragments":[{"kind":"keyword","text":"func"},{"kind":"text","text":" "},{"text":"convert","kind":"identifier"},{"text":"(","kind":"text"},{"text":"within","kind":"externalParam"},{"text":": ","kind":"text"},{"text":"Environment","kind":"typeIdentifier","preciseIdentifier":"s:16EmacsSwiftModule11EnvironmentC"},{"text":") ","kind":"text"},{"kind":"keyword","text":"throws"},{"kind":"text","text":" -> "},{"preciseIdentifier":"s:16EmacsSwiftModule0A5ValueC","kind":"typeIdentifier","text":"EmacsValue"}]},"doc://EmacsSwiftModule/documentation/EmacsSwiftModule/EmacsConvertible":{"role":"symbol","type":"topic","title":"EmacsConvertible","kind":"symbol","url":"\/documentation\/emacsswiftmodule\/emacsconvertible","fragments":[{"kind":"keyword","text":"protocol"},{"kind":"text","text":" "},{"text":"EmacsConvertible","kind":"identifier"}],"abstract":[{"type":"text","text":"The main protocol for value conversions between Emacs Lisp and Swift."}],"identifier":"doc:\/\/EmacsSwiftModule\/documentation\/EmacsSwiftModule\/EmacsConvertible","navigatorTitle":[{"kind":"identifier","text":"EmacsConvertible"}]},"doc://EmacsSwiftModule/documentation/EmacsSwiftModule/CallingLispFunctions":{"role":"article","type":"topic","kind":"article","title":"Calling Lisp Functions","url":"\/documentation\/emacsswiftmodule\/callinglispfunctions","abstract":[{"text":"Calling Lisp functions from your Swift code.","type":"text"}],"identifier":"doc:\/\/EmacsSwiftModule\/documentation\/EmacsSwiftModule\/CallingLispFunctions"},"doc://EmacsSwiftModule/documentation/EmacsSwiftModule/EmacsValue":{"role":"symbol","type":"topic","title":"EmacsValue","kind":"symbol","url":"\/documentation\/emacsswiftmodule\/emacsvalue","fragments":[{"kind":"keyword","text":"class"},{"text":" ","kind":"text"},{"kind":"identifier","text":"EmacsValue"}],"abstract":[{"type":"text","text":"An opaque Emacs value representing something from the Emacs Lisp world."}],"identifier":"doc:\/\/EmacsSwiftModule\/documentation\/EmacsSwiftModule\/EmacsValue","navigatorTitle":[{"kind":"identifier","text":"EmacsValue"}]},"doc://EmacsSwiftModule/documentation/EmacsSwiftModule/DefiningLispFunctions":{"role":"article","type":"topic","title":"Defining Lisp Functions","kind":"article","url":"\/documentation\/emacsswiftmodule\/defininglispfunctions","abstract":[{"type":"text","text":"Defining Emacs Lisp functions directly from Swift."}],"identifier":"doc:\/\/EmacsSwiftModule\/documentation\/EmacsSwiftModule\/DefiningLispFunctions"},"doc://EmacsSwiftModule/documentation/EmacsSwiftModule/ErrorHandling":{"role":"article","type":"topic","title":"Error Handling","kind":"article","url":"\/documentation\/emacsswiftmodule\/errorhandling","abstract":[{"text":"Handling Lisp errors on Swift side and vice versa.","type":"text"}],"identifier":"doc:\/\/EmacsSwiftModule\/documentation\/EmacsSwiftModule\/ErrorHandling"},"doc://EmacsSwiftModule/documentation/EmacsSwiftModule/EmacsConvertible/convert(from:within:)-2h782":{"url":"\/documentation\/emacsswiftmodule\/emacsconvertible\/convert(from:within:)-2h782","title":"convert(from:within:)","type":"topic","fragments":[{"kind":"keyword","text":"static"},{"text":" ","kind":"text"},{"kind":"keyword","text":"func"},{"kind":"text","text":" "},{"text":"convert","kind":"identifier"},{"kind":"text","text":"("},{"text":"from","kind":"externalParam"},{"kind":"text","text":": "},{"text":"EmacsValue","kind":"typeIdentifier","preciseIdentifier":"s:16EmacsSwiftModule0A5ValueC"},{"kind":"text","text":", "},{"kind":"externalParam","text":"within"},{"kind":"text","text":": "},{"preciseIdentifier":"s:16EmacsSwiftModule11EnvironmentC","kind":"typeIdentifier","text":"Environment"},{"text":") ","kind":"text"},{"text":"throws","kind":"keyword"},{"text":" -> ","kind":"text"},{"kind":"typeIdentifier","text":"Self"}],"kind":"symbol","required":true,"defaultImplementations":1,"identifier":"doc:\/\/EmacsSwiftModule\/documentation\/EmacsSwiftModule\/EmacsConvertible\/convert(from:within:)-2h782","role":"symbol","abstract":[{"type":"text","text":"Convert given EmacsValue value into the value of the current type within the given environment."}]},"doc://EmacsSwiftModule/documentation/EmacsSwiftModule/DefiningAModule":{"role":"article","type":"topic","title":"Defining a module","kind":"article","url":"\/documentation\/emacsswiftmodule\/definingamodule","abstract":[{"type":"text","text":"Defining a new Emacs module from Swift."}],"identifier":"doc:\/\/EmacsSwiftModule\/documentation\/EmacsSwiftModule\/DefiningAModule"},"doc://EmacsSwiftModule/documentation/EmacsSwiftModule/ConsCell":{"role":"symbol","type":"topic","kind":"symbol","title":"ConsCell","url":"\/documentation\/emacsswiftmodule\/conscell","fragments":[{"kind":"keyword","text":"struct"},{"kind":"text","text":" "},{"text":"ConsCell","kind":"identifier"}],"abstract":[{"type":"text","text":"Emacs cons cell"}],"identifier":"doc:\/\/EmacsSwiftModule\/documentation\/EmacsSwiftModule\/ConsCell","navigatorTitle":[{"kind":"identifier","text":"ConsCell"}]},"doc://EmacsSwiftModule/documentation/EmacsSwiftModule/OpaquelyEmacsConvertible":{"role":"symbol","type":"topic","kind":"symbol","title":"OpaquelyEmacsConvertible","url":"\/documentation\/emacsswiftmodule\/opaquelyemacsconvertible","fragments":[{"kind":"keyword","text":"protocol"},{"text":" ","kind":"text"},{"kind":"identifier","text":"OpaquelyEmacsConvertible"}],"abstract":[{"type":"text","text":"The protocol for converting custom Swift object into opaque Emacs values."}],"identifier":"doc:\/\/EmacsSwiftModule\/documentation\/EmacsSwiftModule\/OpaquelyEmacsConvertible","navigatorTitle":[{"kind":"identifier","text":"OpaquelyEmacsConvertible"}]}}}