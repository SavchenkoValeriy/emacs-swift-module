{"primaryContentSections":[{"kind":"content","content":[{"text":"defun","anchor":"defun","type":"heading","level":2},{"inlineContent":[{"type":"reference","isActive":true,"identifier":"doc:\/\/EmacsSwiftModule\/documentation\/EmacsSwiftModule\/Environment"},{"text":" provides many overloads of the ","type":"text"},{"type":"codeVoice","code":"defun"},{"text":" method allowing you to convert Swift functions to Lisp functions.","type":"text"},{"type":"text","text":" "},{"text":"All the variants take 3 arguments:","type":"text"}],"type":"paragraph"},{"type":"unorderedList","items":[{"content":[{"type":"paragraph","inlineContent":[{"text":"optional name for a new function (","type":"text"},{"type":"codeVoice","code":"nil"},{"type":"text","text":" for lambda)"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"docstring (empty by default)"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"text":"function implementation as a Swift closure","type":"text"}]}]}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"It returns an opaque "},{"type":"reference","identifier":"doc:\/\/EmacsSwiftModule\/documentation\/EmacsSwiftModule\/EmacsValue","isActive":true},{"text":" that can be called via ","type":"text"},{"type":"codeVoice","code":"funcall"},{"type":"text","text":" or "},{"type":"codeVoice","code":"apply"},{"text":" (mostly useful for lambda functions).","type":"text"},{"text":" ","type":"text"},{"text":"If something goes wrong on the Emacs side, it can throw ","type":"text"},{"identifier":"doc:\/\/EmacsSwiftModule\/documentation\/EmacsSwiftModule\/EmacsError","isActive":true,"type":"reference"},{"text":", however, it is much less likely compared to calls.","type":"text"}]},{"inlineContent":[{"text":"Let’s start with this simple example to see how it works:","type":"text"}],"type":"paragraph"},{"syntax":"swift","code":["env.defun(\"swift-+\") { (lhs: Int, rhs: Int) -> Int in lhs + rhs }"],"type":"codeListing"},{"inlineContent":[{"text":"This will define a Lisp function named ","type":"text"},{"type":"codeVoice","code":"swift-+"},{"text":" taking exactly two arguments. You can call it like any other Lisp function.","type":"text"}],"type":"paragraph"},{"code":["(swift-+ 1 1) ;; => 2"],"type":"codeListing","syntax":"emacs-lisp"},{"inlineContent":[{"text":"If you pass not integers as arguments, you get ","type":"text"},{"type":"codeVoice","code":"wrong-type-argument"},{"type":"text","text":" like with any other Lisp function expecting certain types from its arguments."}],"type":"paragraph"},{"type":"paragraph","inlineContent":[{"text":"You can use any type that is convertible to Lisp (see ","type":"text"},{"identifier":"doc:\/\/EmacsSwiftModule\/documentation\/EmacsSwiftModule\/TypeConversions","type":"reference","isActive":true},{"type":"text","text":") as your closure argument\/return types to get this sweet automatic conversion."}]},{"anchor":"Acquiring-the-Environment","type":"heading","text":"Acquiring the Environment","level":2},{"type":"paragraph","inlineContent":[{"text":"Our ","type":"text"},{"code":"swift-+","type":"codeVoice"},{"type":"text","text":" function is nice, but we don’t communicate with Emacs internals in it, while in the majority of cases we’d want to call a thing or two from the Lisp side. Since our code is a closure, we might have a temptation to simply capture the "},{"type":"reference","isActive":true,"identifier":"doc:\/\/EmacsSwiftModule\/documentation\/EmacsSwiftModule\/Environment"},{"text":" variable and use it. DON’T DO THAT. See more on the reasons in ","type":"text"},{"type":"reference","identifier":"doc:\/\/EmacsSwiftModule\/documentation\/EmacsSwiftModule\/Lifetimes","isActive":true},{"type":"text","text":", but for now just remember to add it as a parameter into your closure."}]},{"code":["env.defun(\"swift-+\") {","  (env: Environment, lhs: Int, rhs: Int) throws -> Int in","  try env.funcall(\"+\", with: lhs, rhs)","}"],"type":"codeListing","syntax":"swift"},{"type":"paragraph","inlineContent":[{"text":"This new version still can be called exactly the same way, but now it calls a Lisp function itself.","type":"text"}]},{"name":"Important","content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Don’t capture environment in your function’s body. If you need it, add it as a first parameter of your closure."}]}],"type":"aside","style":"important"},{"type":"heading","text":"Using Opaque Values","anchor":"Using-Opaque-Values","level":2},{"inlineContent":[{"type":"text","text":"Sometimes we don’t want to use a fancy conversion in our function and we simply want to forward our dynamically typed argument to another Lisp function. This is totally valid and we can use "},{"type":"reference","identifier":"doc:\/\/EmacsSwiftModule\/documentation\/EmacsSwiftModule\/EmacsValue","isActive":true},{"type":"text","text":" directly in our function’s signature."}],"type":"paragraph"},{"code":["env.defun(\"to-string\") {","  (env: Environment, value: EmacsValue) throws -> String in","  try env.funcall(\"format\", with: \"%S\", value)","}"],"type":"codeListing","syntax":"swift"},{"type":"paragraph","inlineContent":[{"text":"This function takes an opaque value and forwards it to another function. We re-throw any exceptions coming from that call, so if that function has some type expectation for it’s argument, the user still gets notified about it.","type":"text"}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Opaque values have very specific lifetime rules to them. Please, check "},{"isActive":true,"type":"reference","identifier":"doc:\/\/EmacsSwiftModule\/documentation\/EmacsSwiftModule\/Lifetimes"},{"type":"text","text":" for more detail."}]}],"style":"important","name":"Important","type":"aside"}]}],"schemaVersion":{"minor":3,"major":0,"patch":0},"sections":[],"metadata":{"role":"article","title":"Defining Lisp Functions","modules":[{"name":"EmacsSwiftModule"}],"roleHeading":"Article"},"abstract":[{"text":"Defining Emacs Lisp functions directly from Swift.","type":"text"}],"seeAlsoSections":[{"identifiers":["doc:\/\/EmacsSwiftModule\/documentation\/EmacsSwiftModule\/DefiningAModule","doc:\/\/EmacsSwiftModule\/documentation\/EmacsSwiftModule\/CallingLispFunctions","doc:\/\/EmacsSwiftModule\/documentation\/EmacsSwiftModule\/TypeConversions","doc:\/\/EmacsSwiftModule\/documentation\/EmacsSwiftModule\/ErrorHandling"],"generated":true,"title":"Getting started"}],"variants":[{"traits":[{"interfaceLanguage":"swift"}],"paths":["\/documentation\/emacsswiftmodule\/defininglispfunctions"]}],"identifier":{"interfaceLanguage":"swift","url":"doc:\/\/EmacsSwiftModule\/documentation\/EmacsSwiftModule\/DefiningLispFunctions"},"hierarchy":{"paths":[["doc:\/\/EmacsSwiftModule\/documentation\/EmacsSwiftModule"],["doc:\/\/EmacsSwiftModule\/documentation\/EmacsSwiftModule","doc:\/\/EmacsSwiftModule\/documentation\/EmacsSwiftModule\/Environment"]]},"kind":"article","references":{"doc://EmacsSwiftModule/documentation/EmacsSwiftModule/ErrorHandling":{"role":"article","type":"topic","title":"Error Handling","kind":"article","url":"\/documentation\/emacsswiftmodule\/errorhandling","abstract":[{"text":"Handling Lisp errors on Swift side and vice versa.","type":"text"}],"identifier":"doc:\/\/EmacsSwiftModule\/documentation\/EmacsSwiftModule\/ErrorHandling"},"doc://EmacsSwiftModule/documentation/EmacsSwiftModule":{"role":"collection","abstract":[{"type":"text","text":"A Swift library to write Emacs plugins in Swift!"}],"title":"EmacsSwiftModule","url":"\/documentation\/emacsswiftmodule","identifier":"doc:\/\/EmacsSwiftModule\/documentation\/EmacsSwiftModule","kind":"symbol","type":"topic"},"doc://EmacsSwiftModule/documentation/EmacsSwiftModule/TypeConversions":{"role":"article","type":"topic","title":"Type conversions","kind":"article","url":"\/documentation\/emacsswiftmodule\/typeconversions","abstract":[{"text":"Converting Swift values into Lisp values and vice versa.","type":"text"}],"identifier":"doc:\/\/EmacsSwiftModule\/documentation\/EmacsSwiftModule\/TypeConversions"},"doc://EmacsSwiftModule/documentation/EmacsSwiftModule/CallingLispFunctions":{"role":"article","type":"topic","kind":"article","title":"Calling Lisp Functions","url":"\/documentation\/emacsswiftmodule\/callinglispfunctions","abstract":[{"text":"Calling Lisp functions from your Swift code.","type":"text"}],"identifier":"doc:\/\/EmacsSwiftModule\/documentation\/EmacsSwiftModule\/CallingLispFunctions"},"doc://EmacsSwiftModule/documentation/EmacsSwiftModule/EmacsValue":{"role":"symbol","type":"topic","title":"EmacsValue","kind":"symbol","url":"\/documentation\/emacsswiftmodule\/emacsvalue","fragments":[{"kind":"keyword","text":"class"},{"text":" ","kind":"text"},{"kind":"identifier","text":"EmacsValue"}],"abstract":[{"type":"text","text":"An opaque Emacs value representing something from the Emacs Lisp world."}],"identifier":"doc:\/\/EmacsSwiftModule\/documentation\/EmacsSwiftModule\/EmacsValue","navigatorTitle":[{"kind":"identifier","text":"EmacsValue"}]},"doc://EmacsSwiftModule/documentation/EmacsSwiftModule/Lifetimes":{"role":"article","type":"topic","kind":"article","title":"Lifetimes","url":"\/documentation\/emacsswiftmodule\/lifetimes","abstract":[{"type":"text","text":"Emacs internals lifetimes."}],"identifier":"doc:\/\/EmacsSwiftModule\/documentation\/EmacsSwiftModule\/Lifetimes"},"doc://EmacsSwiftModule/documentation/EmacsSwiftModule/EmacsError":{"role":"symbol","type":"topic","kind":"symbol","title":"EmacsError","url":"\/documentation\/emacsswiftmodule\/emacserror","fragments":[{"kind":"keyword","text":"enum"},{"kind":"text","text":" "},{"text":"EmacsError","kind":"identifier"}],"abstract":[{"type":"text","text":"The main type representing Emacs errors."}],"identifier":"doc:\/\/EmacsSwiftModule\/documentation\/EmacsSwiftModule\/EmacsError","navigatorTitle":[{"kind":"identifier","text":"EmacsError"}]},"doc://EmacsSwiftModule/documentation/EmacsSwiftModule/Environment":{"role":"symbol","type":"topic","title":"Environment","kind":"symbol","url":"\/documentation\/emacsswiftmodule\/environment","fragments":[{"kind":"keyword","text":"class"},{"text":" ","kind":"text"},{"kind":"identifier","text":"Environment"}],"abstract":[{"type":"text","text":"Environment is the interaction point with Emacs. If you want to do anything on the Emacs side, you need to have an Environment."}],"identifier":"doc:\/\/EmacsSwiftModule\/documentation\/EmacsSwiftModule\/Environment","navigatorTitle":[{"kind":"identifier","text":"Environment"}]},"doc://EmacsSwiftModule/documentation/EmacsSwiftModule/DefiningAModule":{"role":"article","type":"topic","title":"Defining a module","kind":"article","url":"\/documentation\/emacsswiftmodule\/definingamodule","abstract":[{"type":"text","text":"Defining a new Emacs module from Swift."}],"identifier":"doc:\/\/EmacsSwiftModule\/documentation\/EmacsSwiftModule\/DefiningAModule"}}}