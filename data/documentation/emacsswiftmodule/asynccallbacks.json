{"kind":"article","schemaVersion":{"patch":0,"major":0,"minor":3},"metadata":{"title":"Asynchronous Callbacks","modules":[{"name":"EmacsSwiftModule"}],"role":"article","roleHeading":"Article"},"abstract":[{"type":"text","text":"Calling Lisp functions without an active Environment."}],"primaryContentSections":[{"content":[{"text":"Overview","type":"heading","anchor":"Overview","level":2},{"type":"paragraph","inlineContent":[{"type":"text","text":"As it was mentioned in "},{"isActive":true,"type":"reference","identifier":"doc:\/\/EmacsSwiftModule\/documentation\/EmacsSwiftModule\/Lifetimes"},{"type":"text","text":", "},{"isActive":true,"identifier":"doc:\/\/EmacsSwiftModule\/documentation\/EmacsSwiftModule\/Environment","type":"reference"},{"text":" instances could not be stored and captured. Additionally, dynamic modules are not allowed to use given environments from a different thread they were given it on. This can be a problem if we want to use one of the rich Swift APIs to do some useful work for us. We do want to tell the Emacs side that the work was done, and pass in some results. ","type":"text"},{"identifier":"doc:\/\/EmacsSwiftModule\/documentation\/EmacsSwiftModule\/Channel","isActive":true,"type":"reference"},{"text":" mechanism was designed specifically with this goal in mind and it provides multiple ways of passing data back into Lisp.","type":"text"}]},{"anchor":"Creating-a-Channel","level":2,"text":"Creating a Channel","type":"heading"},{"type":"paragraph","inlineContent":[{"text":"In order to create a ","type":"text"},{"isActive":true,"type":"reference","identifier":"doc:\/\/EmacsSwiftModule\/documentation\/EmacsSwiftModule\/Channel"},{"type":"text","text":", you do need to have an active environment. Simply call "},{"type":"reference","isActive":true,"identifier":"doc:\/\/EmacsSwiftModule\/documentation\/EmacsSwiftModule\/Environment\/openChannel(name:)"},{"text":" with a name for that channel, and that’s pretty much it. You are allowed to create multiple channels and use them simultaneously. Channel callbacks are serialized to be called in exactly the same order their Swift counter-parts got called in the first place. Because of this reason, it might be a good idea to have different channels for less frequent important callbacks and more frequent, but less important callbacks.","type":"text"}]},{"type":"heading","level":2,"anchor":"withEnvironment","text":"withEnvironment"},{"type":"paragraph","inlineContent":[{"text":"The easiest way of interacting with ","type":"text"},{"identifier":"doc:\/\/EmacsSwiftModule\/documentation\/EmacsSwiftModule\/Environment","type":"reference","isActive":true},{"text":" using an open ","type":"text"},{"identifier":"doc:\/\/EmacsSwiftModule\/documentation\/EmacsSwiftModule\/Channel","isActive":true,"type":"reference"},{"type":"text","text":" is via "},{"type":"reference","identifier":"doc:\/\/EmacsSwiftModule\/documentation\/EmacsSwiftModule\/Channel\/withEnvironment(_:)","isActive":true},{"text":". This function allows you to execute some code with Emacs environment whenever we’ll get it from Emacs.","type":"text"}]},{"type":"codeListing","code":["\/\/ do some work","channel.withEnvironment {","  env throws in try env.funcall(\"message\", with: \"The work is done!\")","}","\/\/ keep doing something else"],"syntax":"swift"},{"type":"paragraph","inlineContent":[{"type":"text","text":"It should be noted that the code from "},{"code":"\/\/ keep doing something else","type":"codeVoice"},{"text":" will most likely get executed before before our message will appear in Emacs. For this reason, ","type":"text"},{"code":"withEnvironment","type":"codeVoice"},{"type":"text","text":" (and other callbacks) don’t have return values."}]},{"anchor":"callback","text":"callback","type":"heading","level":2},{"inlineContent":[{"type":"text","text":"In many cases, we want to adapt some asynchronous APIs to Lisp. Let’s say we have a UI form that represents a text-field or something similar. When the user submits the form, a callback is called with the user-written text. We probably don’t want to do anything with this text on the Swift side, but our module can pass it to the Lisp side. Of course, we can implement it using "},{"identifier":"doc:\/\/EmacsSwiftModule\/documentation\/EmacsSwiftModule\/Channel\/withEnvironment(_:)","isActive":true,"type":"reference"},{"type":"text","text":":"}],"type":"paragraph"},{"code":["form.onSubmit {","  (text: String) in","  channel.withEnvironment {","    env throws in try env.funcall(\"lisp-on-submit\", with: text)","  }","}"],"type":"codeListing","syntax":"swift"},{"inlineContent":[{"type":"text","text":"Instead of having to closures, we can use one of the "},{"code":"callback","type":"codeVoice"},{"text":" methods.","type":"text"}],"type":"paragraph"},{"code":["form.onSubmit(channel.callback {","  (env: Environment, text: String) throws in","  try env.funcall(\"lisp-on-submit\", with: text)","})"],"syntax":"swift","type":"codeListing"},{"inlineContent":[{"type":"text","text":"This family of methods turns closures that have "},{"identifier":"doc:\/\/EmacsSwiftModule\/documentation\/EmacsSwiftModule\/Environment","isActive":true,"type":"reference"},{"type":"text","text":" as its first parameter into closures that don’t. In our example, it’s "},{"type":"codeVoice","code":"((Environment, String) -> Void) -> (String) -> Void"},{"type":"text","text":"."}],"type":"paragraph"},{"type":"paragraph","inlineContent":[{"type":"text","text":"This way, we can write the code that would’ve been very similar to the code that doesn’t need to communicate with Emacs in the first place. However, sometimes we don’t even need to do anything else except for communicating with Lisp."}]},{"inlineContent":[{"type":"text","text":"Let’s extend our previous example:"}],"type":"paragraph"},{"syntax":"swift","type":"codeListing","code":["try env.defun(\"create-form\") {","  (onSubmit: PersistentEmacsValue) in","  let form = new Form()","  form.onSubmit(channel.callback {","    (env: Environment, text: String) throws in","    try env.funcall(onSubmit, with: text)","  })","  return form","}"]},{"type":"paragraph","inlineContent":[{"text":"Here, we expose form creation to Lisp in its entirety, and allow users to create it when they want it and have a callback completely on the Lisp side. This code works, but feels a bit wordy. For this reason, ","type":"text"},{"isActive":true,"type":"reference","identifier":"doc:\/\/EmacsSwiftModule\/documentation\/EmacsSwiftModule\/Channel"},{"type":"text","text":" provides a family of methods also named "},{"code":"callback","type":"codeVoice"},{"type":"text","text":" that work with "},{"isActive":true,"type":"reference","identifier":"doc:\/\/EmacsSwiftModule\/documentation\/EmacsSwiftModule\/EmacsValue"},{"type":"text","text":" functions directly. Let’s look at how we can rewrite our code first."}]},{"type":"codeListing","syntax":"swift","code":["try env.defun(\"create-form\") {","  (onSubmit: PersistentEmacsValue) in","  let form = new Form()","  form.onSubmit(channel.callback(onSubmit))","  return form","}"]},{"type":"paragraph","inlineContent":[{"text":"That’s it, we turned ","type":"text"},{"type":"codeVoice","code":"onSubmit"},{"type":"text","text":" Lisp function into a Swift closure: "},{"type":"codeVoice","code":"(String) -> Void"},{"text":". You can use this formula with all kinds of closure types, ","type":"text"},{"identifier":"doc:\/\/EmacsSwiftModule\/documentation\/EmacsSwiftModule\/Channel","isActive":true,"type":"reference"},{"text":" will create a Swift closure exactly of type that’s expected by the API. Of course, since we call into a Lisp function, it means that all arguments should be ","type":"text"},{"identifier":"doc:\/\/EmacsSwiftModule\/documentation\/EmacsSwiftModule\/EmacsConvertible","type":"reference","isActive":true},{"text":" (see ","type":"text"},{"identifier":"doc:\/\/EmacsSwiftModule\/documentation\/EmacsSwiftModule\/TypeConversions","isActive":true,"type":"reference"},{"type":"text","text":")."}]},{"text":"hooks","anchor":"hooks","level":2,"type":"heading"},{"inlineContent":[{"text":"Emacs Lisp has a different way of notifying some code of system-wide events, - hooks. In some cases, it would be the most appropriate tool to use for designing our module’s API. ","type":"text"},{"isActive":true,"type":"reference","identifier":"doc:\/\/EmacsSwiftModule\/documentation\/EmacsSwiftModule\/Channel"},{"type":"text","text":" also provides a family of "},{"type":"codeVoice","code":"hook"},{"type":"text","text":" methods that you can use this way:"}],"type":"paragraph"},{"type":"codeListing","syntax":"swift","code":["try env.defun(\"create-form\") {","  let form = new Form()","  form.onSubmit(channel.hook(\"form-submit-hooks\"))","  return form","}"]},{"type":"paragraph","inlineContent":[{"text":"Essentially, it does the same thing as the ","type":"text"},{"type":"codeVoice","code":"callback"},{"type":"text","text":" method in the earlier snippet, but it runs a hook instead."}]},{"text":"Asynchronous Results","type":"heading","anchor":"Asynchronous-Results","level":2},{"inlineContent":[{"text":"There is one scenario, however, that the callbacks in this form couldn’t cover - getting data from the Lisp side.","type":"text"}],"type":"paragraph"},{"inlineContent":[{"type":"text","text":"Let’s consider the following scenario, we are writing an integration with some web API and need to do quite a lot of work in the background. We do this asynchronously, so we don’t block Emacs. At some point, we find out that authentication cookies had expired and need to ask the user to put in their password again."}],"type":"paragraph"},{"type":"codeListing","syntax":"swift","code":["if cookies.isInvalid() {","  var userPassword = \"\"","  channel.withEnvironment {","    env in userPassword = try env.funcall(\"password-read\", with: \"Password: \")","  }","  \/\/ use userPassword?","}"]},{"inlineContent":[{"type":"text","text":"The problem with this code is that we don’t know when "},{"type":"codeVoice","code":"passord-read"},{"text":" is going to get executed and when we can actually use ","type":"text"},{"type":"codeVoice","code":"userPassword"},{"text":". Of course, we can implement some form of busy waiting and check ","type":"text"},{"code":"userPassword","type":"codeVoice"},{"type":"text","text":" from time to time, but this doesn’t seem very appealing."}],"type":"paragraph"},{"type":"paragraph","inlineContent":[{"text":"Instead, ","type":"text"},{"code":"EmacsSwiftModule","type":"codeVoice"},{"type":"text","text":" leverages "},{"type":"codeVoice","code":"async\/await"},{"text":" model of Swift in ","type":"text"},{"identifier":"doc:\/\/EmacsSwiftModule\/documentation\/EmacsSwiftModule\/Channel\/withAsyncEnvironment(_:)","isActive":true,"type":"reference"},{"text":" to efficiently and seamlessly request data from Emacs and the user.","type":"text"}]},{"type":"codeListing","syntax":"swift","code":["if cookies.isInvalid() {","  let userPassword: String = try await channel.withAsyncEnvironment {","    env in try env.funcall(\"password-read\", with: \"Password: \")","  }","  \/\/ use userPassword","}"]}],"kind":"content"}],"seeAlsoSections":[{"generated":true,"title":"Advanced","identifiers":["doc:\/\/EmacsSwiftModule\/documentation\/EmacsSwiftModule\/Lifetimes"]}],"sections":[],"variants":[{"traits":[{"interfaceLanguage":"swift"}],"paths":["\/documentation\/emacsswiftmodule\/asynccallbacks"]}],"identifier":{"interfaceLanguage":"swift","url":"doc:\/\/EmacsSwiftModule\/documentation\/EmacsSwiftModule\/AsyncCallbacks"},"hierarchy":{"paths":[["doc:\/\/EmacsSwiftModule\/documentation\/EmacsSwiftModule"],["doc:\/\/EmacsSwiftModule\/documentation\/EmacsSwiftModule","doc:\/\/EmacsSwiftModule\/documentation\/EmacsSwiftModule\/Environment"]]},"references":{"doc://EmacsSwiftModule/documentation/EmacsSwiftModule/EmacsValue":{"role":"symbol","type":"topic","title":"EmacsValue","kind":"symbol","url":"\/documentation\/emacsswiftmodule\/emacsvalue","fragments":[{"kind":"keyword","text":"class"},{"text":" ","kind":"text"},{"kind":"identifier","text":"EmacsValue"}],"abstract":[{"type":"text","text":"An opaque Emacs value representing something from the Emacs Lisp world."}],"identifier":"doc:\/\/EmacsSwiftModule\/documentation\/EmacsSwiftModule\/EmacsValue","navigatorTitle":[{"kind":"identifier","text":"EmacsValue"}]},"doc://EmacsSwiftModule/documentation/EmacsSwiftModule/Channel":{"role":"symbol","type":"topic","title":"Channel","kind":"symbol","url":"\/documentation\/emacsswiftmodule\/channel","fragments":[{"kind":"keyword","text":"class"},{"kind":"text","text":" "},{"text":"Channel","kind":"identifier"}],"abstract":[{"type":"text","text":"A communication channel that can be used at all times."}],"identifier":"doc:\/\/EmacsSwiftModule\/documentation\/EmacsSwiftModule\/Channel","navigatorTitle":[{"kind":"identifier","text":"Channel"}]},"doc://EmacsSwiftModule/documentation/EmacsSwiftModule/Environment":{"role":"symbol","type":"topic","title":"Environment","kind":"symbol","url":"\/documentation\/emacsswiftmodule\/environment","fragments":[{"kind":"keyword","text":"class"},{"text":" ","kind":"text"},{"kind":"identifier","text":"Environment"}],"abstract":[{"type":"text","text":"Environment is the interaction point with Emacs. If you want to do anything on the Emacs side, you need to have an Environment."}],"identifier":"doc:\/\/EmacsSwiftModule\/documentation\/EmacsSwiftModule\/Environment","navigatorTitle":[{"kind":"identifier","text":"Environment"}]},"doc://EmacsSwiftModule/documentation/EmacsSwiftModule/Channel/withEnvironment(_:)":{"role":"symbol","kind":"symbol","title":"withEnvironment(_:)","type":"topic","identifier":"doc:\/\/EmacsSwiftModule\/documentation\/EmacsSwiftModule\/Channel\/withEnvironment(_:)","url":"\/documentation\/emacsswiftmodule\/channel\/withenvironment(_:)","abstract":[{"text":"Execute the given closure with Emacs environment.","type":"text"}],"fragments":[{"kind":"keyword","text":"func"},{"text":" ","kind":"text"},{"text":"withEnvironment","kind":"identifier"},{"text":"((","kind":"text"},{"text":"Environment","kind":"typeIdentifier","preciseIdentifier":"s:16EmacsSwiftModule11EnvironmentC"},{"kind":"text","text":") "},{"kind":"keyword","text":"throws"},{"kind":"text","text":" -> "},{"text":"Void","kind":"typeIdentifier","preciseIdentifier":"s:s4Voida"},{"kind":"text","text":")"}]},"doc://EmacsSwiftModule/documentation/EmacsSwiftModule/Lifetimes":{"role":"article","type":"topic","kind":"article","title":"Lifetimes","url":"\/documentation\/emacsswiftmodule\/lifetimes","abstract":[{"type":"text","text":"Emacs internals lifetimes."}],"identifier":"doc:\/\/EmacsSwiftModule\/documentation\/EmacsSwiftModule\/Lifetimes"},"doc://EmacsSwiftModule/documentation/EmacsSwiftModule/EmacsConvertible":{"role":"symbol","type":"topic","title":"EmacsConvertible","kind":"symbol","url":"\/documentation\/emacsswiftmodule\/emacsconvertible","fragments":[{"kind":"keyword","text":"protocol"},{"kind":"text","text":" "},{"text":"EmacsConvertible","kind":"identifier"}],"abstract":[{"type":"text","text":"The main protocol for value conversions between Emacs Lisp and Swift."}],"identifier":"doc:\/\/EmacsSwiftModule\/documentation\/EmacsSwiftModule\/EmacsConvertible","navigatorTitle":[{"kind":"identifier","text":"EmacsConvertible"}]},"doc://EmacsSwiftModule/documentation/EmacsSwiftModule/Channel/withAsyncEnvironment(_:)":{"role":"symbol","kind":"symbol","title":"withAsyncEnvironment(_:)","type":"topic","identifier":"doc:\/\/EmacsSwiftModule\/documentation\/EmacsSwiftModule\/Channel\/withAsyncEnvironment(_:)","url":"\/documentation\/emacsswiftmodule\/channel\/withasyncenvironment(_:)","abstract":[{"type":"text","text":"Execute the given closure with Emacs environment and return its result."}],"fragments":[{"kind":"keyword","text":"func"},{"kind":"text","text":" "},{"text":"withAsyncEnvironment","kind":"identifier"},{"text":"<","kind":"text"},{"text":"R","kind":"genericParameter"},{"text":">((","kind":"text"},{"text":"Environment","preciseIdentifier":"s:16EmacsSwiftModule11EnvironmentC","kind":"typeIdentifier"},{"text":") ","kind":"text"},{"text":"throws","kind":"keyword"},{"kind":"text","text":" -> "},{"kind":"typeIdentifier","text":"R"},{"kind":"text","text":") "},{"kind":"keyword","text":"async"},{"text":" ","kind":"text"},{"kind":"keyword","text":"throws"},{"text":" -> ","kind":"text"},{"text":"R","kind":"typeIdentifier"}]},"doc://EmacsSwiftModule/documentation/EmacsSwiftModule/TypeConversions":{"role":"article","type":"topic","title":"Type conversions","kind":"article","url":"\/documentation\/emacsswiftmodule\/typeconversions","abstract":[{"text":"Converting Swift values into Lisp values and vice versa.","type":"text"}],"identifier":"doc:\/\/EmacsSwiftModule\/documentation\/EmacsSwiftModule\/TypeConversions"},"doc://EmacsSwiftModule/documentation/EmacsSwiftModule/Environment/openChannel(name:)":{"role":"symbol","type":"topic","kind":"symbol","title":"openChannel(name:)","url":"\/documentation\/emacsswiftmodule\/environment\/openchannel(name:)","fragments":[{"kind":"keyword","text":"func"},{"text":" ","kind":"text"},{"kind":"identifier","text":"openChannel"},{"kind":"text","text":"("},{"text":"name","kind":"externalParam"},{"kind":"text","text":": "},{"kind":"typeIdentifier","preciseIdentifier":"s:SS","text":"String"},{"kind":"text","text":") "},{"text":"throws","kind":"keyword"},{"kind":"text","text":" -> "},{"kind":"typeIdentifier","preciseIdentifier":"s:16EmacsSwiftModule7ChannelC","text":"Channel"}],"abstract":[{"type":"text","text":"Open a communication channel with Emacs for the time when Environment is not available."}],"identifier":"doc:\/\/EmacsSwiftModule\/documentation\/EmacsSwiftModule\/Environment\/openChannel(name:)"},"doc://EmacsSwiftModule/documentation/EmacsSwiftModule":{"role":"collection","abstract":[{"type":"text","text":"A Swift library to write Emacs plugins in Swift!"}],"title":"EmacsSwiftModule","url":"\/documentation\/emacsswiftmodule","identifier":"doc:\/\/EmacsSwiftModule\/documentation\/EmacsSwiftModule","kind":"symbol","type":"topic"}}}